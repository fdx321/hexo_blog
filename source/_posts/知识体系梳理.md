title: 知识体系梳理
date: 2017-10-25 09:36:59
tags:
---
**[1] Java 线程的状态**
![300](/images/知识体系梳理_1.png)

**[2] 进程和线程的区别，进程之间如何通讯，线程之间如何通讯？**

进程有自己的地址空间和运行环境，他们之间的通讯其实可以理解成应用之间的通讯，可以通过管道、网络等来通讯。线程拥有更少的资源，一个进程可以有多个线程，线程之间的通讯则可以通过锁、信号量等来实现同步，可以通过共享内存的方式来实现数据的通讯。

**[3]HashMap的实现原理是什么？和HashTable、ConcurrentHashMap有什么区别**

以下的回答是基于JDK 1.8来说的。

HashMap 里有几个关键的概念，
* capacity，默认是16，也可以手动指定，但最后会被计算成2的指数倍。
* loadFactor，默认是0.75
* threadShold，阈值(capacity*loadFactor)，超过这个阈值就会做resize，resize会double Map的capacity.
HashMap里是用一个 Node[] 数组来存储数据的，Node 有以下几个关键的属性：hash, key, value, next. 
put 操作的时候，根据对象的hash值找到数组下标，没有被占就直接放进去，如果有值了，就通过 next 串起来。当链表的大小超过TREEIFY_THRESHOLD的时候，会对这个链表进行树化操作，将Node 转换成 TreeNode（多了prev, left, right等属性）

HashTable 和 HashMap 最大的区别，
* HashTable 是线程安全的，实现上就是在方法上加了 synchronized
* HashTable key 不予许为 null，null 的话会抛异常
* 实现上比较简单，没有树化的操作


ConcurrentHashMap 和 HashTable 一样是线程安全的，但 HashTable锁的粒度比较大，ConcurrentHashMap 采用的Segment，锁里的粒度是在Segment上，性能更好，

**[4]索引**
下面的讨论不考虑考虑全文索引(MyISAM)，Hash索引，只针对B树索引，索引的实现原理，B+树：
![400](/images/知识体系梳理_2.jpg)
了解了索引的实现原理后，在创建索引的时候，需要关注这么几个事项：
* 区分度
* 最左匹配，并不是说在写SQL的时候要按这个顺序写，而是在建索引的时候要考虑这个顺序

聚簇索引和非聚簇索引，以及他们各自的优缺点。
![400](/images/知识体系梳理_3.jpg)
3A索引，1. 索引全部都走到； 2. 数据全在索引上，不需要二次索引； 3. 排序字段刚好也是索引




**[5]事务的隔离级别**
如下，但这是SQL92的标准，具体数据库的实现和这个是有出入的。能够举例说明脏读、不可重复读、幻象读等各类情况是什么意思。

|隔离级别|脏读|不可重复读|幻象读|第一类更新丢失|第二类更新丢失|
|----|----|---|----|----|
|READ UNCOMMITED|会|会|会|不会|会|
|READ COMMITED|不会|会|会|不会|会|
|REPEATABLE READ|不会|不会|会|不会|不会|
|SERIALIZABLE|不会|不会|不会|不会|不会|

**[6]Spring事务的传播级别**
传播级别比较多，重点关注以下三个。能够举例（代码）说明这三种传播级别都是什么意思。

|类型|说明|
|--|--|
|PROPAGATION_REQUIRED|如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是 最常见的选择。|
|PROPAGATION_REQUIRES_NEW|新建事务，如果当前存在事务，把当前事务挂起|
|PROPAGATION_NESTED|如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与 PROPAGATION_REQUIRED 类似的操作|

**[7]一致性Hash及它的使用场景**
**[8]为什么 equals 和 hashcode要一起重写**
**[9]Object类有哪些方法**
equals/hashcode/clone/toString/wait/notify

**[10]JVM内存模型**
![400](/images/知识体系梳理_4.png)
**[11]JVM运行时数据区**
![400](/images/知识体系梳理_5.png)
**[12]GC算法**
评价一个GC算法有以下几个标准：
* 吞吐量，单位时间的处理能力
* 最大暂停时间(Stop The World)
* 堆使用效率
* 访问的局部性
首先来看下一些经典的GC算法以及他们各自的优缺点，然后再来看JVM中的GC. 下面说的都是最基础的算法，实际的比这复杂很多很多。
* 标记-清除
 主要有标记、清除、合并、分配几个操作，优点是简单，缺点是碎片化，分配速度慢
* 引用计数
即刻回收，最大暂停时间短，缺点就是计数复杂，计数器占用空间
* 复制算法
分两块内存，每次GC把活得的对象copy到另一块，之前的一块直接全部干掉。
优点，吞吐量高（这里要思考为什么吞吐量高），没有碎片化，分配速度也快，缺点就是堆使用率低
 
 上面的GC都有各自的优缺点，分代GC就是综合几种GC算法的一种GC方式。
 ![500](/images/知识体系梳理_6.jpg)
 青年代使用复制算法，老年代使用标记算法，但这里存在一个问题，可能会存在**跨代引用**（挺多人踩过这个坑，可以关注下）的问题。

 JVM里这么几种垃圾收集器
 ![500](/images/知识体系梳理_7.jpg)



**[13]标什么情况下回出现Full GC，什么情况下会出现Young GC**
Young GC
1. Eden发生GC的时候

Full GC
1. System.GC()
2. 年轻代晋升到老年代，要在老年代分配空间的时候，发现空间不够时
3. 分配担保

**[14]线程池**
```java
Executor
ExecutorService
Executors
Runnable

newFixedThreadPool
newSingleThreadExecutor
newCachedThreadPool

public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler)
https://github.com/fdx321/gitbook_code/blob/master/jdk_1_8/concurrent/threadpoolexecutorjava.md

                          
```



**[15]Runnable/Callable/Future/FutureTask**


**[17]如何写代码让程序出现各种OOM或StackoverFlow**
首先你得知道JVM的内存布局，以及这些内存都是干什么用的。
HeapOutOfMemory
Young OutOfMemory，年轻代溢出,MaxTenuringThreshold设置的很大，让年轻代的对象永远无法晋升到老年代
MethodArea OutOfMemory, 用ClassLoader加载很多类
ConstantPool OutOfMemory
DirectMemory OutOfMemory
Stack OutOfMemory Stack OverFlow，一直递归调用

**[18]长轮询**
为什么要使用长轮询（Push, Pull 分析各自的优缺点）、怎么实现

**[19]几个常用的JDK命令**
jps, jstack, jmap, jconsole, jinfo, jhat, javap, …

**[20]长连接为什么需要发心跳包？**

**[21]ClassLoader**
![500](/images/知识体系梳理_8.png)
双亲委派，Tomcat为啥打破双亲委派

**[22]HTTP协议**
200 404 401 400 405 500 502
**[23]TCP协议**
三次握手、四次挥手、Time_Await、拥塞控制、超时重试、保活
**[24]数据库连接池实现原理**
看过MyBatis自带连接池、DBCP以及Druid的源码，可以总结一下他们的共同点和区别。



**[25]Netty线程池是怎么用的**

**[26]AOP实现原理**

**[27]Spring的启动过程**

**[28]自己开发框架如何与Spring集成**

**[29]SPI扩展点**

**[30]Tomcat**
**[31]RPC**
**[32]MQ**
**[33]介绍几种常用的设计模式以及他们的使用场景**
**[34]分布式事务，两阶段提交**
**[35]如何实现分布式锁**
**[36]如何实现分布式Session**
**[37]聊聊负载均衡**
**[38]聊聊缓存的使用**
**[39]CDN实现原理**
**[40]秒杀系统设计**
**[41]超卖问题**
**[42]Fork Join**
**[43]JVM的一些关键参数是什么意思**
-Xmx -Xms -Xmn -Xss
-XX:NewRatio -XX:SurvivorRatio
-XX:NewSize， -XX:MaxNewSize -XX:MaxTenuringThreshold
**[44]动态代理**
**[45]ThreadLocal**
**[46]Nio**
**[47]Sleep和Wait**
**[48]wait和notify**
**[49]volatile**












<style>
img[title="200"] {
  width:200px;
  display: block;
}

img[title="300"] {
  width:300px;
  width:300px;
  display: block;
}
img[title="400"] {
  width:400px;
  display: block;
}
img[title="500"] {
  width:500px;
  display: block;
}
img[title="600"] {
  width:600px;
  display: block;
}
</style>
